import {InvalidArgument, InvalidElement, RuntimeException} from "../errors.js";
import {AriaAttr, CustomAttr} from "../misc/attributes.js";
import ns from "../misc/namespaces.js";
import snippets from "./snippets.js";
import IconTransform from "./IconTransform.js";
import Pictogram from "./Pictogram.js";


// Private attributes
const _aria = new WeakMap();
const _connector = new WeakMap();
const _element = new WeakMap();
const _meta = new WeakMap();
const _pictogram = new WeakMap();
const _svgElement = new WeakMap();
const _tfmInstance = new WeakMap();

/**
 * Represents a SVG icon item, which is composed by a declarative HTML Element
 * and by a generated SVGElement linked to a {@link Pictogram}.
 */
class Icon {

  /**
   * Constructor of the object.
   * @param {!HTMLElement} element - The element used to report the location of the icon from the document.
   * @throws {InvalidElement} When the `element` argument is wrong.
   */
  constructor(element) {
    if (!(element instanceof HTMLElement)) {
      throw new InvalidElement("HTMLElement", element);
    }

    const connector = Icon.snippets.connector.cloneNode();
    const svgElement = Icon.snippets.icon.cloneNode();

    element.setAttribute("role", "img");
    svgElement.appendChild(connector);

    _aria.set(this, new AriaAttr(element));
    _connector.set(this, connector);
    _element.set(this, element);
    _meta.set(this, new CustomAttr(element));
    _pictogram.set(this, Pictogram.replacement);
    _svgElement.set(this, svgElement);
    // _tfmInstance.set(this, null);

    // ReadOnly properties
    Object.defineProperties(this, {
      aria: { get: function() {
        return _aria.get(this);
      }},
      connector: { get: function() {
        return _connector.get(this);
      }},
      element: { get: function() {
        return _element.get(this);
      }},
      meta: { get: function() {
        return _meta.get(this);
      }},
      pictogram: { get: function() {
        return _pictogram.get(this);
      }},
      svgElement: { get: function() {
        return _svgElement.get(this);
      }}
    });
  }

  /**
   * Applies the changes provided by the customized attributes of the element
   * @example <span data-icon="foo" data-rotate="45"></span>
   */
  applyTransforms() {
    if (this.meta.has("rotate")) {
      this.transform().rotate(this.meta.get("rotate"));
    } else if (this.meta.has("flip-x")) {
      this.transform().flipX();
    } else if (this.meta.has("flip-y")) {
      this.transform().flipY();
    } else if (this.meta.has("translate")) {
      const [x,y] = this.meta.get("translate").split(",", 2);
      this.transform().translate(x, y);
    }
  }

  /**
   * Displays the icon in the document.
   * @param {!Pictogram} pictogram - The pictogram to be displayed by the icon.
   */
  draw(pictogram) {
    if (!(pictogram instanceof Pictogram)) {
      throw new InvalidArgument("Invalid Pictogram");
    }
    // this.erase();
    _pictogram.set(this, pictogram);

    // Adds DOM nodes required for rendering
    this.element.appendChild(this.svgElement);

    // Force the viewBox attribute. In principle it is not necessary but in
    // reality, the display is buggy on most browsers without it.
    const vb = pictogram.getViewBox();
    const vbStr = [vb.x, vb.y, vb.width, vb.height].join(" ");
    this.svgElement.setAttribute(
      "viewBox",
      vbStr
    );

    // Applies aria complentary informations if they are not override by direct
    // label and descriptions.
    if (pictogram.titleID && !this.aria.has("label")) {
      this.aria.set("labelledby", pictogram.titleID);
    }
    if (pictogram.descID && !this.aria.has("description")) {
      this.aria.set("descriptedby", pictogram.descID);
    }

    // Links to the pictogram
    this.connector.setAttributeNS(ns.xlink, "xlink:href", pictogram.getIRI());

    // Applies transformations provided by attributes
    this.applyTransforms();
  }

  /**
   * Cleans the component before its destruction.
   */
  remove() {
    // Empties the element of its children.
    const elem = this.element;
    while(elem.firstChild) {
      elem.removeChild(elem.firstChild);
    }

    // Deletes the attributes generated by the component.
    this.aria.remove("labelledby");
    this.aria.remove("descriptedby");

    // Purges the private attributes.
    _aria.delete(this);
    _connector.delete(this);
    _element.delete(this);
    _meta.delete(this);
    _pictogram.delete(this);
    _svgElement.delete(this);
    _tfmInstance.delete(this);
  }

  /**
   * Returns the size infos of the icon.
   * @returns {Object} An object with the size and its position of the icon.
   */
  getSize() {
    return this.svgElement.getBoundingClientRect();
  }

  /**
   * Returns the icon reference size
   * @returns {number} Corresponds to the longer side of the icon.
   */
  getRefSize() {
    const size = this.getSize();
    return Math.max(size.height, size.width);
  }

  /**
   * Loads a Transform instance of the icon.
   * @returns {IconTransform} The transform object of the icon.
   */
  transform() {
    let tfm = _tfmInstance.get(this);
    if (!tfm) {
      if (!this.svgElement) {
        throw new RuntimeException("Unable to transform a non-drawn icon.");
      }
      tfm = new IconTransform(this.connector);
      _tfmInstance.set(this, tfm);
    }
    return tfm;
  }

}

/**
 * Snippets used by the component for draw the icon.
 */
Icon.snippets = snippets;


export default Icon;
